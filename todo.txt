

[ ] add exFAT?




[ ] Full support for FAT32 on >512 byte sectors

[ ] If two FATs exist, highlight non-matching entries in RED

[ ] Fix FAT type detection:
CountOfClusters := count of *DATA* clusters
                   starting at cluster 2
                   (the first data cluster)
Thus, maximum "cluster number" is CountOfClusters + 1

if (SectorHasBpbSignature()) {
    if (CountofClusters < 4085) && hasFat12Bpb()) {
        /* Volume is FAT12 */
    } else if ((CountofClusters < 65525) && hasFat16Bpb()) {
        /* Volume is FAT16 */
    } else if (hasExfatBpb()) {
        /* Volume is exFAT */
    } else if (hasFat32Bpb()) {
        /* Volume is FAT32 */
    }
}


[ ] Remove global state from FAT_DIR_ENTRY
//
// UPDATED BY:
//       FAT_CheckDirEntryRead()
// USED BY:
//       FAT_DIR_ENTRY() - to finish at proper location in file
//
// Special local variables used when defining FAT dir entries.
//
// Valid only within the context of a SINGLE FAT_DIR_ENTRY creation,
// (which is really a conceptual entry, as could include many LFN).
// Required because the "directory entry set" may not be contiguous
// (e.g., may start and end in different, non-contiguous clusters).
//
// New design:
//     define structure holding these three entries
//     at start of FAT_DIR_ENTRY, allocate a local variable of this type
//     Modify  FAT_CheckDirEntryRead() to take this structure as an argument
//     RESULT: clearer code 
//

[ ] Rename FAT_DIR_ENTRY to FAT_DIRECTORY_ENTRY_SET


###########################################################
[ ] Add FAT12 partition type

[ ] FAT12 should likely use BitFieldDisablePadding()
    and BitFieldEnablePadding() to read FAT entries
    as a stream of bits....
###########################################################

[ ] FAT_JumpToCluster()
[ ] FAT_AddressToCluster()

[ ] rename 'cluster' to 'cluster number' or
    'cluster index' as appropriate throughout

###########################################################
###########################################################

[ ] fix tLFN_RecordSeqNum to reflect below logic
    for handling LFN entries....

[ ] Ensure check for LFN entry...
    1. check if attributes & 0x3F == 0x0F
    2. check if byte[0] (LDIR_Ord) != 0xE5 ("last" dir entry)
    3. if byte[0] & 0x40 == 0x40
       a. if already started LFN, mark old LFN as "orphans"
          and discard them...
       b. set var remaining_lfn_entries = byte[0] & 0x0F
       c. allocate space for remaining_lfn_entries * 13 characters
    4. if remaining_lfn_entries > 0
       a. extract characters into the temporary LFN name buffer
          starting at index = remaining_lfn_entries * 13


[ ] Update DRIVE_NOT_SUPPORTED union with exFAT and/or FAT12


###########################################################
###########################################################
###########################################################

[x] fix FAT_DIR_ENTRY struct also...
[x] fix FAT directory entry attribute FAT_ATTR_TYPE
    to match specification.

[x] fix readFAT_SHORTENTRY() to handle when
    first character == 0x05 --> converts to
    KANJI lead byte value 0xE5 (valid in Japan)

[x] fix readFAT_SHORTENTRY() to handle when
    upper bits of the attribute flags are set
    (e.g., mask with 0x3F ... ??)

[x] <format=hex>

[x] Add <read=ReadFAT16_CLUSTERINFO> to show hex for special values

[x] Add <read=ReadFAT32_CLUSTERINFO> to show hex for special values

[x] Clarify number of entries per FAT

[x] begin initial support for non-512 sectors sizes for FAT32

[x] Detect and handle some types of orphaned LFN entries (sequence number)
    NOTE: Does not yet check CRC of short-entry name against LFN values.

[x] Fix data corruption regression (off-by-two error) caused by earlier
    changes to include indices 0 and 1 in FAT table.

[x] Add a number of utility functions to simplify code:
    ReadFAT_SHORTENTRY_Filename
    FAT_DirectoryEntryType         (masks to valid bits only)
    FAT_IsDirectoryEntryLFN
    FAT_IsDirectoryEntryVolumeID   (excludes LFN entries)
    ReadFAT_SHORTENTRY_IsDeleted
    ReadFAT_DIR_ENTRY_IsDeleted
    ReadFAT_DIR_ENTRY_IsDirectory
    ReadFAT_DIR_ENTRY_LongFilename

[x] Fixes to displayed filenames in many cases.

[x] Add FAT_ATTR_ prefix to FAT_ATTR_TYPE enumeration values.
    This helps avoid naming conflicts, especially where these attributes
    included such common names as "system".

[x] Change additional enum values to have a prefix (help avoid naming conflicts).
    FAT16_MEDIATYPE      ==> FAT16_MEDIA_TYPE     , with prefix FAT16_MEDIATYPE_
    FAT16_PARTITIONSTATE ==> FAT16_PARTITION_STATE, with prefix FAT16_PARTITION_
    FAT16_CLUSTERINFO    ==> FAT16_CLUSTER_INFO   , with prefix FAT16_CLUSTER_
    FAT32_MEDIATYPE      ==> FAT32_MEDIA_TYPE     , with prefix FAT32_MEDIATYPE_
    FAT32_PARTITIONSTATE ==> FAT32_PARTITION_STATE, with prefix FAT32_PARTITION_
    FAT32_CLUSTERINFO    ==> FAT32_CLUSTER_INFO   , with prefix FAT32_CLUSTER_


